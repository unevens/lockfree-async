<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lockfree-async: lockfree::Async&lt; TClassToStore &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lockfree-async
   </div>
   <div id="projectbrief">A C++17 header-only template library for lock-free inter-thread communication and sharing of resources.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>lockfree</b></li><li class="navelem"><a class="el" href="classlockfree_1_1_async.html">Async</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlockfree_1_1_async-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lockfree::Async&lt; TClassToStore &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and non-blocking manner.  
 <a href="classlockfree_1_1_async.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_lock_free_async_8hpp_source.html">LockFreeAsync.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async_1_1_awaiter.html">Awaiter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af9171df1ad73df27870cdb9e5ee9ea2a"><td class="memItemLeft" align="right" valign="top"><a id="af9171df1ad73df27870cdb9e5ee9ea2a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ClassToStore</b> = TClassToStore</td></tr>
<tr class="separator:af9171df1ad73df27870cdb9e5ee9ea2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d6bfa6e82077672be6e91fea68995"><td class="memItemLeft" align="right" valign="top"><a id="a772d6bfa6e82077672be6e91fea68995"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Message</b> = std::function&lt; void(TClassToStore &amp;)&gt;</td></tr>
<tr class="separator:a772d6bfa6e82077672be6e91fea68995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711d1b0101f6075b17ad19cd68b00d0c"><td class="memItemLeft" align="right" valign="top"><a id="a711d1b0101f6075b17ad19cd68b00d0c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GetterInterface</b> = <a class="el" href="classlockfree_1_1_t_getter_interface.html">TGetterInterface</a>&lt; ClassToStore &gt;</td></tr>
<tr class="separator:a711d1b0101f6075b17ad19cd68b00d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f082781d48f11a8cb54adc2364d589a"><td class="memItemLeft" align="right" valign="top"><a id="a0f082781d48f11a8cb54adc2364d589a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BlockingGetterInterface</b> = <a class="el" href="classlockfree_1_1_t_blocking_getter_interface.html">TBlockingGetterInterface</a>&lt; ClassToStore &gt;</td></tr>
<tr class="separator:a0f082781d48f11a8cb54adc2364d589a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc49b5637ab0c0c88b5807260806906"><td class="memTemplParams" colspan="2"><a id="a9dc49b5637ab0c0c88b5807260806906"></a>
template&lt;class TClassToGet  = TClassToStore&gt; </td></tr>
<tr class="memitem:a9dc49b5637ab0c0c88b5807260806906"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Getter</b> = <a class="el" href="classlockfree_1_1_t_getter.html">TGetter</a>&lt; TClassToGet, ClassToStore &gt;</td></tr>
<tr class="separator:a9dc49b5637ab0c0c88b5807260806906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a069e9c09fb3f0fab28b745ffca8e4"><td class="memTemplParams" colspan="2"><a id="a48a069e9c09fb3f0fab28b745ffca8e4"></a>
template&lt;class TClassToGet  = TClassToStore&gt; </td></tr>
<tr class="memitem:a48a069e9c09fb3f0fab28b745ffca8e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BlockingGetter</b> = <a class="el" href="classlockfree_1_1_t_blocking_getter.html">TBlockingGetter</a>&lt; TClassToGet, ClassToStore &gt;</td></tr>
<tr class="separator:a48a069e9c09fb3f0fab28b745ffca8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb0ed0d21249b865ee5546fab4502956"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#adb0ed0d21249b865ee5546fab4502956">submitMessage</a> (<a class="el" href="classlockfree_1_1_message_node.html">MessageNode</a>&lt; Message &gt; *messageNode)</td></tr>
<tr class="memdesc:adb0ed0d21249b865ee5546fab4502956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message already wrapped in a <a class="el" href="classlockfree_1_1_message_node.html" title="Template class for the nodes of lock-free multiple-producer multiple-consumer LIFO stack.">MessageNode</a>.  <a href="classlockfree_1_1_async.html#adb0ed0d21249b865ee5546fab4502956">More...</a><br /></td></tr>
<tr class="separator:adb0ed0d21249b865ee5546fab4502956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fb2fd2c2e403743e9009c85345af7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a52fb2fd2c2e403743e9009c85345af7a">submitMessage</a> (Message message)</td></tr>
<tr class="memdesc:a52fb2fd2c2e403743e9009c85345af7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message that is not already wrapped in a <a class="el" href="classlockfree_1_1_message_node.html" title="Template class for the nodes of lock-free multiple-producer multiple-consumer LIFO stack.">MessageNode</a>.  <a href="classlockfree_1_1_async.html#a52fb2fd2c2e403743e9009c85345af7a">More...</a><br /></td></tr>
<tr class="separator:a52fb2fd2c2e403743e9009c85345af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d645af17ea1695bb31a9ecfc4ef9fb4"><td class="memTemplParams" colspan="2">template&lt;class TClassToGet  = TClassToStore&gt; </td></tr>
<tr class="memitem:a8d645af17ea1695bb31a9ecfc4ef9fb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlockfree_1_1_t_getter.html">Getter</a>&lt; TClassToGet &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a8d645af17ea1695bb31a9ecfc4ef9fb4">requestGetter</a> ()</td></tr>
<tr class="memdesc:a8d645af17ea1695bb31a9ecfc4ef9fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests an Getter.  <a href="classlockfree_1_1_async.html#a8d645af17ea1695bb31a9ecfc4ef9fb4">More...</a><br /></td></tr>
<tr class="separator:a8d645af17ea1695bb31a9ecfc4ef9fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081ce651a0a9f22fa3126a325b2ad2ef"><td class="memTemplParams" colspan="2">template&lt;class TClassToGet  = TClassToStore&gt; </td></tr>
<tr class="memitem:a081ce651a0a9f22fa3126a325b2ad2ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlockfree_1_1_t_blocking_getter.html">BlockingGetter</a>&lt; TClassToGet &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a081ce651a0a9f22fa3126a325b2ad2ef">requestBlockingGetter</a> ()</td></tr>
<tr class="memdesc:a081ce651a0a9f22fa3126a325b2ad2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a BlockingGetter.  <a href="classlockfree_1_1_async.html#a081ce651a0a9f22fa3126a325b2ad2ef">More...</a><br /></td></tr>
<tr class="separator:a081ce651a0a9f22fa3126a325b2ad2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b46adf0e28ae76d6e5b964a0df7de67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlockfree_1_1_async_1_1_awaiter.html">Awaiter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a3b46adf0e28ae76d6e5b964a0df7de67">requestAwaiter</a> ()</td></tr>
<tr class="memdesc:a3b46adf0e28ae76d6e5b964a0df7de67"><td class="mdescLeft">&#160;</td><td class="mdescRight">An awaiter is like a blocking access points, but it does not own a copy of the stored object.  <a href="classlockfree_1_1_async.html#a3b46adf0e28ae76d6e5b964a0df7de67">More...</a><br /></td></tr>
<tr class="separator:a3b46adf0e28ae76d6e5b964a0df7de67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98688231402bf8f4ac13841336ccc13f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlockfree_1_1_message_buffer.html">MessageBuffer</a>&lt; Message &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a98688231402bf8f4ac13841336ccc13f">requestMessageBuffer</a> (std::function&lt; Message(void)&gt; initializer, int numPreallocatedNodes, int minNumNodes)</td></tr>
<tr class="memdesc:a98688231402bf8f4ac13841336ccc13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a <a class="el" href="classlockfree_1_1_message_buffer.html" title="A class that holds a stack of message nodes initialized with a functor and ready to be sent.">MessageBuffer</a>.  <a href="classlockfree_1_1_async.html#a98688231402bf8f4ac13841336ccc13f">More...</a><br /></td></tr>
<tr class="separator:a98688231402bf8f4ac13841336ccc13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c9e7c781a2f40e91f63d474adefe41"><td class="memItemLeft" align="right" valign="top"><a id="a48c9e7c781a2f40e91f63d474adefe41"></a>
<a class="el" href="classlockfree_1_1_message_node.html">MessageNode</a>&lt; Message &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a48c9e7c781a2f40e91f63d474adefe41">getMessageNodeFromStorage</a> ()</td></tr>
<tr class="memdesc:a48c9e7c781a2f40e91f63d474adefe41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a preallocated node. <br /></td></tr>
<tr class="separator:a48c9e7c781a2f40e91f63d474adefe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac618db9c4efc2feb61110af88368ebd5"><td class="memItemLeft" align="right" valign="top"><a id="ac618db9c4efc2feb61110af88368ebd5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#ac618db9c4efc2feb61110af88368ebd5">startTimer</a> ()</td></tr>
<tr class="memdesc:ac618db9c4efc2feb61110af88368ebd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the <a class="el" href="classlockfree_1_1_async.html" title="A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and no...">Async</a>'s timer, spawning its timer thread. <br /></td></tr>
<tr class="separator:ac618db9c4efc2feb61110af88368ebd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081cd720fe0b4abfa538f0355a7ba298"><td class="memItemLeft" align="right" valign="top"><a id="a081cd720fe0b4abfa538f0355a7ba298"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a081cd720fe0b4abfa538f0355a7ba298">stopTimer</a> ()</td></tr>
<tr class="memdesc:a081cd720fe0b4abfa538f0355a7ba298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the <a class="el" href="classlockfree_1_1_async.html" title="A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and no...">Async</a>'s timer, joining its timer thread. <br /></td></tr>
<tr class="separator:a081cd720fe0b4abfa538f0355a7ba298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13fd1a28c4fde0fc72fa9357d0cff88"><td class="memItemLeft" align="right" valign="top"><a id="ae13fd1a28c4fde0fc72fa9357d0cff88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#ae13fd1a28c4fde0fc72fa9357d0cff88">setTimerPeriod</a> (int period)</td></tr>
<tr class="memdesc:ae13fd1a28c4fde0fc72fa9357d0cff88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the period of the timer thread that handles the messages. <br /></td></tr>
<tr class="separator:ae13fd1a28c4fde0fc72fa9357d0cff88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d302b567e0c9c414bfa95ad623c816c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a7d302b567e0c9c414bfa95ad623c816c">isRunning</a> ()</td></tr>
<tr class="separator:a7d302b567e0c9c414bfa95ad623c816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0929ee5e4d0cc0e95166ee7783bd9d0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlockfree_1_1_async.html#a0929ee5e4d0cc0e95166ee7783bd9d0f">Async</a> (ClassToStore storedObject, std::function&lt; void(ClassToStore &amp;)&gt; onChange=nullptr, int timerPeriod=50, int numNodesToPreallocate=32, std::function&lt; Message(void)&gt; messageInitialzier=[] { return <a class="el" href="classlockfree_1_1_async.html">Async</a>&lt; TClassToStore &gt;::Message();})</td></tr>
<tr class="memdesc:a0929ee5e4d0cc0e95166ee7783bd9d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classlockfree_1_1_async.html#a0929ee5e4d0cc0e95166ee7783bd9d0f">More...</a><br /></td></tr>
<tr class="separator:a0929ee5e4d0cc0e95166ee7783bd9d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TClassToStore&gt;<br />
class lockfree::Async&lt; TClassToStore &gt;</h3>

<p>A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and non-blocking manner. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TClassToStore</td><td>the type of the object to share. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0929ee5e4d0cc0e95166ee7783bd9d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0929ee5e4d0cc0e95166ee7783bd9d0f">&#9670;&nbsp;</a></span>Async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TClassToStore&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlockfree_1_1_async.html">lockfree::Async</a>&lt; TClassToStore &gt;::<a class="el" href="classlockfree_1_1_async.html">Async</a> </td>
          <td>(</td>
          <td class="paramtype">ClassToStore&#160;</td>
          <td class="paramname"><em>storedObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(ClassToStore &amp;)&gt;&#160;</td>
          <td class="paramname"><em>onChange</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timerPeriod</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numNodesToPreallocate</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Message(void)&gt;&#160;</td>
          <td class="paramname"><em>messageInitialzier</em> = <code>[]&#160;{&#160;return&#160;<a class="el" href="classlockfree_1_1_async.html">Async</a>&lt;TClassToStore&gt;::Message();&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storedObject</td><td>the ClassToStore object to share </td></tr>
    <tr><td class="paramname">onChange</td><td>functor called on the ClassToStore whenever it is updated by messages </td></tr>
    <tr><td class="paramname">timerPeriod</td><td>period of the timer thread that handles the messages. </td></tr>
    <tr><td class="paramname">numNodesToPreallocate</td><td>number of message nodes to preallocate. </td></tr>
    <tr><td class="paramname">messageInitialzier</td><td>functor to initialize the preallocated nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7d302b567e0c9c414bfa95ad623c816c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d302b567e0c9c414bfa95ad623c816c">&#9670;&nbsp;</a></span>isRunning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TClassToStore&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlockfree_1_1_async.html">lockfree::Async</a>&lt; TClassToStore &gt;::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the timer thread is running, false otherwise. </dd></dl>

</div>
</div>
<a id="a3b46adf0e28ae76d6e5b964a0df7de67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b46adf0e28ae76d6e5b964a0df7de67">&#9670;&nbsp;</a></span>requestAwaiter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TClassToStore&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlockfree_1_1_async_1_1_awaiter.html">Awaiter</a> <a class="el" href="classlockfree_1_1_async.html">lockfree::Async</a>&lt; TClassToStore &gt;::requestAwaiter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An awaiter is like a blocking access points, but it does not own a copy of the stored object. </p>
<p>You can use it to wait for the next iteration of the timerCallback. </p><dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classlockfree_1_1_async_1_1_awaiter.html">Awaiter</a> object </dd></dl>

</div>
</div>
<a id="a081ce651a0a9f22fa3126a325b2ad2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081ce651a0a9f22fa3126a325b2ad2ef">&#9670;&nbsp;</a></span>requestBlockingGetter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TClassToStore&gt; </div>
<div class="memtemplate">
template&lt;class TClassToGet  = TClassToStore&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlockfree_1_1_t_blocking_getter.html">BlockingGetter</a>&lt;TClassToGet&gt;* <a class="el" href="classlockfree_1_1_async.html">lockfree::Async</a>&lt; TClassToStore &gt;::requestBlockingGetter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests a BlockingGetter. </p>
<p>This should not be called while the <a class="el" href="classlockfree_1_1_async.html" title="A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and no...">Async</a>'s timer is running. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TClassToGet</td><td>a type that can be constructed from the ClassToStore, to store what the access point needs from the ClassToStore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the requested BlockingGetter, or nullptr if the <a class="el" href="classlockfree_1_1_async.html" title="A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and no...">Async</a>'s timer is running </dd></dl>

</div>
</div>
<a id="a8d645af17ea1695bb31a9ecfc4ef9fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d645af17ea1695bb31a9ecfc4ef9fb4">&#9670;&nbsp;</a></span>requestGetter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TClassToStore&gt; </div>
<div class="memtemplate">
template&lt;class TClassToGet  = TClassToStore&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlockfree_1_1_t_getter.html">Getter</a>&lt;TClassToGet&gt;* <a class="el" href="classlockfree_1_1_async.html">lockfree::Async</a>&lt; TClassToStore &gt;::requestGetter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests an Getter. </p>
<p>This should not be called while the <a class="el" href="classlockfree_1_1_async.html" title="A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and no...">Async</a>'s timer is running. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TClassToGet</td><td>a type that can be constructed from the ClassToStore, to store what the access point needs from the ClassToStore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the requested Getter, or nullptr if the <a class="el" href="classlockfree_1_1_async.html" title="A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and no...">Async</a>'s timer is running </dd></dl>

</div>
</div>
<a id="a98688231402bf8f4ac13841336ccc13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98688231402bf8f4ac13841336ccc13f">&#9670;&nbsp;</a></span>requestMessageBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TClassToStore&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlockfree_1_1_message_buffer.html">MessageBuffer</a>&lt;Message&gt;* <a class="el" href="classlockfree_1_1_async.html">lockfree::Async</a>&lt; TClassToStore &gt;::requestMessageBuffer </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Message(void)&gt;&#160;</td>
          <td class="paramname"><em>initializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPreallocatedNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minNumNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests a <a class="el" href="classlockfree_1_1_message_buffer.html" title="A class that holds a stack of message nodes initialized with a functor and ready to be sent.">MessageBuffer</a>. </p>
<p>This should not be called while the <a class="el" href="classlockfree_1_1_async.html" title="A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and no...">Async</a>'s timer is running. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classlockfree_1_1_message_buffer.html" title="A class that holds a stack of message nodes initialized with a functor and ready to be sent.">MessageBuffer</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initializer</td><td>functor used by the message buffer to initialize its nodes </td></tr>
    <tr><td class="paramname">numPreallocatedNodes</td><td>number of nodes preallcoated by the message buffer </td></tr>
    <tr><td class="paramname">minNumNodes</td><td>number of nodes at which the message buffer will replenish its nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classlockfree_1_1_message_buffer.html" title="A class that holds a stack of message nodes initialized with a functor and ready to be sent.">MessageBuffer</a>, or nullptr if the <a class="el" href="classlockfree_1_1_async.html" title="A class to share and syncrhonize the state of an object among multiple threads, in a lock-free and no...">Async</a>'s timer is running </dd></dl>

</div>
</div>
<a id="a52fb2fd2c2e403743e9009c85345af7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fb2fd2c2e403743e9009c85345af7a">&#9670;&nbsp;</a></span>submitMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TClassToStore&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlockfree_1_1_async.html">lockfree::Async</a>&lt; TClassToStore &gt;::submitMessage </td>
          <td>(</td>
          <td class="paramtype">Message&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message that is not already wrapped in a <a class="el" href="classlockfree_1_1_message_node.html" title="Template class for the nodes of lock-free multiple-producer multiple-consumer LIFO stack.">MessageNode</a>. </p>
<p>This should not be called from realtime threads, because a <a class="el" href="classlockfree_1_1_message_node.html" title="Template class for the nodes of lock-free multiple-producer multiple-consumer LIFO stack.">MessageNode</a> may be allocated under the hood (it will be allocated when there are no available ones, which will happen if messages are sent more often than how often they are handled by the timerCallback). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>the message to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb0ed0d21249b865ee5546fab4502956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0ed0d21249b865ee5546fab4502956">&#9670;&nbsp;</a></span>submitMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TClassToStore&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlockfree_1_1_async.html">lockfree::Async</a>&lt; TClassToStore &gt;::submitMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlockfree_1_1_message_node.html">MessageNode</a>&lt; Message &gt; *&#160;</td>
          <td class="paramname"><em>messageNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message already wrapped in a <a class="el" href="classlockfree_1_1_message_node.html" title="Template class for the nodes of lock-free multiple-producer multiple-consumer LIFO stack.">MessageNode</a>. </p>
<p>non-blocking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageNode</td><td>the message node to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_lock_free_async_8hpp_source.html">LockFreeAsync.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
