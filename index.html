<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lockfree-async: lockfree-async</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lockfree-async
   </div>
   <div id="projectbrief">A C++17 header-only template library for lock-free inter-thread communication and sharing of resources.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">lockfree-async </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/unevens/lockfree-async">lockfree-async</a> is a C++ header-only simple template library for lock-free inter-thread communication.</p>
<p>The fundamental building block of this library is the "IMB Freelist" multiple-producer multiple-consumer LIFO stack, as implemented by Ross Bencina in <a href="https://github.com/RossBencina/QueueWorld">Queue World</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Design</h1>
<p>This library is designed to solve this problem:</p>
<div class="fragment"><div class="line">We have an object, whose state can be changed from many threads, which is also used by one (or more) realtime threads.</div>
<div class="line">In the realtime threads no blocking action should be executed, so we can&#39;t prevent data races by using a mutex.</div>
</div><!-- fragment --><p>Here's the general idea of how this library solves the problem:</p>
<ul>
<li>Let's call <code>State</code> the class of the object we want to share.</li>
<li>The object is not directly visible, but is managed by an instance of the class <code>Async&lt;State&gt;</code>.</li>
<li>The <code>Async&lt;State&gt;</code> instance keeps a private copy of the <code>State</code> object</li>
<li>For each thread that needs to acces the <code>State</code> object, a <code>Getter</code> object can be requested to the <code>Async&lt;State&gt;</code> instance.</li>
<li>Each getter keeps its local copy of the <code>State</code> object - or, optionally, of an object of an other type that can be constructed from the <code>State</code> object. The <code>Getter</code> object have two methods: <code>get</code>, which will return a reference to the local copy of the <code>State</code> object, and <code>update</code>, which will synchronize the local copy with the last available version of the <code>State</code> object kept by the <code>Async&lt;State&gt;</code> instace.</li>
<li><code>Async&lt;State&gt;</code> has a method called <code>SubmitMessage</code>, which can be called from any thread, that takes a <code>std::function&lt;void(State&amp;)&gt;</code> to asynchronously change the state of the object. Let's call a <code>std::function&lt;void(State&amp;)&gt;</code> a <em>message</em>.</li>
<li>The messages are received and executed using a timer thread. They are executed on the private copy of the <code>State</code> object owned by the <code>Asyn&lt;State&gt;</code> istance.</li>
<li>Then, the timer thread will update the local copies of the <code>State</code> object kept by the getters using a lockfree FIFO stack to avoid data races. All memory allocations and deallocations are executed by the timer thread.</li>
</ul>
<p>Read on for a more detailed explanation.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Messages</h2>
<p>Messages are used to asynchronously change the state of the State.</p>
<p>But what is a message? A message is a <code>std::function&lt;void(State&amp;)&gt;</code>.</p>
<p>Just put the code to change you want to execute on the <code>State</code> object in a <code>std::function&lt;void(State&amp;)&gt;</code> and pass it to the <code>Async&lt;State&gt;</code> instance using one of its <code>SubmitMessage</code> methods.</p>
<p>If you need to send such messages from realtime threads, you can preallocate them using the function <code>Async&lt;State&gt;::RequestMessageBuffer</code>.</p>
<p>The Messages are handled in a timer thread. You can set its period in the constructor of <code>Async&lt;State&gt;</code>, or by calling <code>SetTimerPeriod</code>.</p>
<p>The constructor of <code>Async&lt;State&gt;</code> also has an optional argument of type <code>std::function&lt;void(State&amp;)&gt;</code> called <code>onChange</code>. If not null, it will be executed on the <code>State</code> object by timer callback if any message has been received.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Getters</h2>
<p><code>Getter</code> objects can be reqeusted using the method <code>RequestGetter&lt;ClassToGet&gt;</code> of <code>Async&lt;State&gt;</code>. The template parameter <code>ClassToGet</code> is the type that the <code>get</code> method of the getter will return. By default it is <code>State</code>, but it can be anything that can be constructed from a <code>State const&amp;</code>.</p>
<p>When the timer thread of the <code>Async&lt;State&gt;</code> handles the messages and updates its private <code>State</code> object, it will also update the copies of the <code>State</code> owned by the Getters - more precisely, the new versions will be sent to the <code>Getter</code>s using a the lock-free lifo-stack, to avoid data races.</p>
<p>The method <code>update</code> of the <code>Getter</code> swaps its local copy of the <code>State</code> with the last version that the server has sent to it using the the lifo-stack.</p>
<p>The local copy will have been updated by all the messages sent <b>before</b> the last iteration of the timer.</p>
<p>However, the messages sent <em>after the last iteration of the <code>Async&lt;State&gt;</code> timer</em>, even if they were sent <em>before the call to <code>update</code></em>, will not have been handled yet.</p>
<p>Messages are, after all, asynchronous.</p>
<p>In non realtime threads however, you might want to wait for all the messages already sent to the <code>Async&lt;State&gt;</code> to be handled before <code>update</code> returns.</p>
<p>In such case, instead of a <code>Getter</code>, you have to request a <code>BlockingGetter</code> using the method <code>RequestBlockingGetter</code>.</p>
<p>The method <code>update</code> of a <code>BlockingGetter</code> will wait for the next timer iteration, so that all messages already submitted to the <code>Async&lt;State&gt;</code> will have been handled before it returns.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Awaiter</h2>
<p>An <code>Awaiter</code> is an object with only one method: <code>await</code>, which will make the current thread wait for all the already submitted <code>Messages</code> to be handled by the <code>Async&lt;State&gt;</code>, by waiting for the completion of the next timer iteration. Each <code>Awaiter</code> object should only be used by one thread at the same time, as it is for the <code>Getter</code>s.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
LockFreeMessenger.h</h1>
<p>The template class <code>LockFreeMessenger&lt;T&gt;</code> is a wrapper around the Queue World's multiple-producer multiple-consumer LIFO stack. It implements functionality to send and receive data of type <code>T</code> between threads in a lock-free way, and to preallocate the resources to do so.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Documentation</h1>
<p>The documentation, available at <a href="https://unevens.github.io/lockfree-async/,">https://unevens.github.io/lockfree-async/,</a> can be generated with <a href="http://doxygen.nl/">Doxygen</a> running</p>
<div class="fragment"><div class="line">$ doxygen doxyfile.txt</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
